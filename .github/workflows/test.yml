name: Test

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for coverage-badge-action to update gh-pages
      pull-requests: write  # Required for commenting on PRs
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for coverage-badge-action

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true

      - name: Install dependencies
        run: flutter pub get
        working-directory: .

      - name: Verify formatting
        run: dart format --set-exit-if-changed .
        continue-on-error: false

      - name: Analyze code
        run: flutter analyze
        continue-on-error: false

      - name: Run tests with coverage (zenrouter)
        run: flutter test --coverage
        working-directory: packages/zenrouter
        continue-on-error: false

      - name: Run tests with coverage (zenrouter_file_generator)
        run: flutter test --coverage
        working-directory: packages/zenrouter_file_generator
        continue-on-error: false

      - name: Convert coverage to json-summary for each package
        run: |
          # Convert lcov to json-summary format for each package
          mkdir -p coverage
          python3 << 'EOF'
          import json
          import os
          import re
          
          packages = ['zenrouter', 'zenrouter_file_generator']
          
          def parse_lcov_file(lcov_file):
              """Parse lcov file and return total/covered lines"""
              if not os.path.exists(lcov_file):
                  return 0, 0
              
              with open(lcov_file, 'r') as f:
                  content = f.read()
              
              # Extract LF (lines found) and LH (lines hit) from summary
              # LCOV format: each file has LF/LH, and there's a summary at the end
              lf_matches = re.findall(r'LF:(\d+)', content)
              lh_matches = re.findall(r'LH:(\d+)', content)
              
              # Use the last entry which is typically the summary
              total_lines = int(lf_matches[-1]) if lf_matches else 0
              covered_lines = int(lh_matches[-1]) if lh_matches else 0
              
              return total_lines, covered_lines
          
          # Process each package separately
          all_coverages = {}
          total_all_lines = 0
          total_all_covered = 0
          
          for pkg in packages:
              lcov_file = f'packages/{pkg}/coverage/lcov.info'
              total_lines, covered_lines = parse_lcov_file(lcov_file)
              
              if total_lines > 0:
                  pct = round((covered_lines / total_lines * 100), 2)
                  
                  # Create json-summary for this package
                  summary = {
                      'total': {
                          'lines': {
                              'total': total_lines,
                              'covered': covered_lines,
                              'skipped': 0,
                              'pct': pct
                          }
                      }
                  }
                  
                  coverage_file = f'coverage/{pkg}-coverage-summary.json'
                  with open(coverage_file, 'w') as f:
                      json.dump(summary, f, indent=2)
                  
                  print(f'{pkg}: {covered_lines}/{total_lines} lines ({pct}%)')
                  all_coverages[pkg] = summary
                  total_all_lines += total_lines
                  total_all_covered += covered_lines
          
          # Create overall summary
          if total_all_lines > 0:
              overall_pct = round((total_all_covered / total_all_lines * 100), 2)
              overall_summary = {
                  'total': {
                      'lines': {
                          'total': total_all_lines,
                          'covered': total_all_covered,
                          'skipped': 0,
                          'pct': overall_pct
                      }
                  }
              }
              
              with open('coverage/coverage-summary.json', 'w') as f:
                  json.dump(overall_summary, f, indent=2)
              
              print(f'Overall: {total_all_covered}/{total_all_lines} lines ({overall_pct}%)')
          EOF
        continue-on-error: true

      - name: Generate Coverage Badges
        if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        run: |
          python3 << 'EOF'
          import json
          import os
          
          def get_color(pct):
              """Get badge color based on coverage percentage"""
              if pct >= 90: return "4c1"
              elif pct >= 75: return "97ca00"
              elif pct >= 60: return "a4a61d"
              elif pct >= 40: return "dfb317"
              else: return "e05d44"
          
          def generate_badge_svg(coverage_pct):
              """Generate shields.io style SVG badge"""
              color = get_color(coverage_pct)
              pct_str = f"{coverage_pct:.1f}%"
              
              # Calculate text width for dynamic badge width
              label_width = 70
              value_width = len(pct_str) * 6 + 10
              total_width = label_width + value_width
              
              svg = f'''<svg xmlns="http://www.w3.org/2000/svg" width="{total_width}" height="20" role="img" aria-label="Coverage: {pct_str}">
            <title>Coverage: {pct_str}</title>
            <linearGradient id="s" x2="0" y2="100%">
              <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
              <stop offset="1" stop-opacity=".1"/>
            </linearGradient>
            <clipPath id="r">
              <rect width="{total_width}" height="20" rx="3" fill="#fff"/>
            </clipPath>
            <g clip-path="url(#r)">
              <rect width="{label_width}" height="20" fill="#555"/>
              <rect x="{label_width}" width="{value_width}" height="20" fill="#{color}"/>
              <rect width="{total_width}" height="20" fill="url(#s)"/>
            </g>
            <g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" font-size="11">
              <text x="{label_width/2}" y="15" fill="#010101" fill-opacity=".3">Coverage</text>
              <text x="{label_width/2}" y="14">Coverage</text>
              <text x="{label_width + value_width/2}" y="15" fill="#010101" fill-opacity=".3">{pct_str}</text>
              <text x="{label_width + value_width/2}" y="14">{pct_str}</text>
            </g>
          </svg>'''
              return svg
          
          # Generate badges for each package
          packages = [
              ('zenrouter', 'coverage/zenrouter-coverage-summary.json', 'coverage-zenrouter'),
              ('zenrouter_file_generator', 'coverage/zenrouter_file_generator-coverage-summary.json', 'coverage-zenrouter_file_generator'),
              ('overall', 'coverage/coverage-summary.json', 'coverage')
          ]
          
          os.makedirs('badges', exist_ok=True)
          
          for name, file_path, badge_name in packages:
              if os.path.exists(file_path):
                  with open(file_path, 'r') as f:
                      data = json.load(f)
                      pct = data['total']['lines']['pct']
                      svg = generate_badge_svg(pct)
                      
                      badge_path = f'badges/{badge_name}.svg'
                      with open(badge_path, 'w') as f:
                          f.write(svg)
                      print(f'Generated {badge_path}: {pct}%')
          EOF
        continue-on-error: true

      - name: Commit Badges to gh-pages
        if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        run: |
          # Store badges temporarily
          mkdir -p /tmp/badges
          cp badges/*.svg /tmp/badges/ 2>/dev/null || true
          
          # Switch to gh-pages branch
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git fetch origin gh-pages:gh-pages 2>/dev/null || true
          git checkout gh-pages || git checkout --orphan gh-pages
          
          # Copy badges to gh-pages
          mkdir -p badges
          cp /tmp/badges/*.svg badges/ 2>/dev/null || true
          
          # Commit and push
          git add badges/*.svg
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update coverage badges [skip ci]"
            git push origin gh-pages
          fi
        continue-on-error: true

      - name: Comment PR Coverage
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let body = '## ðŸ“Š Coverage Report\n\n';
            let hasCoverage = false;
            
            const packages = [
              { name: 'zenrouter', file: 'coverage/zenrouter-coverage-summary.json' },
              { name: 'zenrouter_file_generator', file: 'coverage/zenrouter_file_generator-coverage-summary.json' },
              { name: 'Overall', file: 'coverage/coverage-summary.json' }
            ];
            
            for (const pkg of packages) {
              if (fs.existsSync(pkg.file)) {
                const coverage = JSON.parse(fs.readFileSync(pkg.file, 'utf8'));
                const pct = coverage.total.lines.pct;
                const covered = coverage.total.lines.covered;
                const total = coverage.total.lines.total;
                
                body += `**${pkg.name}:** ${covered}/${total} lines (${pct}%)\n`;
                hasCoverage = true;
              }
            }
            
            if (hasCoverage) {
              body += '\nCoverage calculated for this PR branch.';
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

